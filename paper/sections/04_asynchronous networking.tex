% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\section{Asynchronous networking using Tokio}
In the chapter before basic examples for TCP and UDP communication in Rust were shown. In those programs the current
thread was blocked when waiting for new connections or incoming messages. This not only results into the program having
to wait for a new message to continue executing the code, it also means that you have to create a new thread for each
connection, if you want to listen to multiple connections at once. This principle is called sequential programming. In
contrast to that there are no blocking functions in asynchronous programming. Instead results are wrapped in so called
futures which represent a result of an otherwise blocking function. This result can be unwrapped when it is actually
needed instead of waiting for the execution in advance. \cite{c18network}

\subsection{The tokio crate}
The core library of Rust is kept very small. Instead it offers a package manager called cargo for easy import of third
party packages. This way those extensions are not bound to the release cycle of Rust and also breaking changes will just
affect one single package instead of the whole library. For compatibility reasons a project can keep using an older
version of a package while upgrading the standard library. The packages of Rust are called crates.

A crate is similar to a binary or library. You can add the name and the version to the dependencies of a project in
order to import it. If you do not want to compile and include a whole library, some crates also offer flags deciding
which parts of the library should be included.

To introduce asynchronous programming to Rust, you usually want to use a crate which enables async methods. In this
chapter the crate "tokio" is used. As the documentation \cite{tokio-doc} states, tokio is a runtime for writing
reliable network applications. It offers tools for working with asynchronous tasks as well as APIs for typical blocking
operations suchs as sockets and filesystem operations.

A task in the context of a tokio program is a non-blocking piece of code. You can use the \rust{tokio::task::spawn}
method to schedule the task on the Tokio runtime and use \rust{await} to wait for the returned value. This is a typical
behavior in asynchronous programming and you can compare a task to a promise in programming languages like JavaScript.

The tokio runtime consists out of three major parts: An I/O event loop, which handles I/O events and dispatches them to
the tasks which are waiting for them, a timer to run tasks after a certain period of time and  a scheduler, which
actually executes the tasks on the different threads. To enable the tokio runtime, you can mark the main function with
the \rust{async} keyword and add the \mintinline{rust}{#[tokio::main]} macro above.

The scheduler swaps around all tasks which need to be run. This means there can be more tasks than threads whilst still
allowing concurrent execution of all tasks. To tell the scheduler that the program is currently waiting for another
task to finish before it can continue running, you can call \rust{await} on the method. This effectively stops the
execution of the current task, waits for the other task to finish and then unwraps the returned result. Contrary to an
execution without the tokio runtime, the scheduler knows when the current task can continue running and uses the
otherwise unused CPU time by letting another task run instead.

\subsection{Programming with futures}
Text

Let us take a look at a small demonstration of futures:

\begin{minted}{Rust}
async fn async_function() {
    println!("Started task1");
    sleep(Duration::from_secs(5))
        .await;
    println!("Finished task1");
}

#[tokio::main]
async fn main() {
    let future1 = async_function();

    let future2 = async {
        println!("Started task2");
        sleep(Duration::from_secs(3))
            .await;
        println!("Finished task2");
    };

    '\textcolor{macro}{join!}'(future1, future2);
}
\end{minted}

The declared types of functions play an important role when working with tokio. This is the reason why the example
above also includes the entire function definitions.

As you can see, the main function is marked as \rust{async} and the tokio macro is used to create a runtime for our
program to run in. Next, the asynchronous function \rust{async_function} is called. The value returned by the function
has the type \rust{std::future::Future}, which wraps the value going to be returned after the computation. The
\rust{Future} is saved in the variable \rust{future1}. This way the tokio runtime actually decides when to evaluate the
function. If \rust{async_function} was not marked as an asynchronous function, the main thread executing the program
would enter the function, completely evaluate it and after that continue executing the main function.

The type of \rust{future2} is also a \rust{Future}, the only difference being that it uses an \rust{async} block
instead of an extra function to define the asynchronous code.

In the end the macro \nohighlight{join!} is used to wait for both futures to complete while executing them
concurrently.

Both functions first print a short message, that they have started executing, then they sleep a certain amount of time
using \rust{tokio::time::sleep} and then print that they have stopped executing. The key part in this is, that the
function wrapped by \rust{future1} is called first and sleeps for 5 seconds, the function wrapped by \rust{future2} is
called afterwards and only sleep for three.

In a blocking environment it would result the program to take more than eight seconds to execute, because first the
returned value of \rust{future1} is evaluated and only after that the value of \rust{future2}. This way, the output
would look like this:

\begin{minted}[frame=lines]{TeX}
Started task1
Finished task1
Started task2
Finished task2
\end{minted}

The only way to avoid the synchronous execution is by explicitly starting two threads and executing both tasks
concurrently. If multiple tasks have to run in parallel and include a lot of blocking operations, you usually do not
want to create a thread for each task as the creation of tasks adds a lot of overhead to the program.

In an asynchronous environment on the other hand, the scheduler swaps the execution when the program reaches an
\rust{await} point. This way, the sleep function does not block the entire program flow and the function wrapped by
\rust{future2} finishes first, even if only executing on one thread. The resulting output of the program looks like
this:

\begin{minted}[frame=lines]{TeX}
Started task1
Started task2
Finished task2
Finished task1
\end{minted}

\subsection{Asynchronous TCP networking}
Text

\begin{minted}{Rust}
let listener = TcpListener::bind(ADDRESS).await?;

loop {
    let (stream, _) = listener.accept().await?;

    handle_client(stream).await?;
}
\end{minted}

\begin{minted}{Rust}
tokio::spawn(async move {
    let mut reader = BufReader::new(&mut stream);

    loop {
        let mut buf = String::new();

        match reader
            .read_line(&mut buf).await {
            Ok(0) => break,
            Ok(size) => print!("{}", buf),
            Err(e) => {
                eprintln!("{}", e);
                stream
                    .shutdown()
                    .await
                    .expect("Shutdown");
                break;
            }
        }
    }
});
\end{minted}

\begin{minted}{Rust}
let mut stream = TcpStream::connect(ADDRESS).await?;

let mut reader = BufReader::new(stdin());

loop {
    let mut buf = String::new();

    match reader
        .read_line(&mut buf).await {
        Ok(_) => {
            if buf.trim() == "exit" {
                stream
                    .shutdown()
                    .await?;
                break;
            }

            let bytes = buf.as_bytes();

            stream
                .write_all(bytes)
                .await
                .expect("Writing");
        }
        Err(e) => {
            eprintln!("{}", e);
            stream.shutdown().await?;
            break;
        }
    }
}
\end{minted}

