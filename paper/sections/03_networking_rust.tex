% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\section{Networking in Rust}
Rust is an open-source programming language developed by Mozilla introducing memory-safety without a runtime or garbage
collection. Its standard library provides networking primitives for basic TPC/UDP communication, which allows socket
communication and error handeling out of the box. \cite{rust-language}

\subsection{Advantages of using Rust for networking}
There are usually different approaches when it comes to picking a language for networking, especially if you want to
implement a new transport protocol on a lower level.

You can use a scripting language like Python or JavaScript. With such languages you are able to easily import libraries
to give you a basic networking API and they offer a simple syntax allowing fast prototyping. As those languages usually
are interpreted, they often perform much slower compared to executing compiled binary files as the instructions first
have to get translated by the interpreter before being executed.

If speed and scalability is an important factor (as it is most of the time), a compiled language can be a good choice.
This is the reason why many networking libraries are written in C or C++. Those two languages do not guarantee memory
safety. If a programmer makes a mistake, the compiler does not check for undefined behavior and just falls back to some
default action and can lead to corruption of memory.

This can particularly be a problem when working with network applications as you often have to read and write to
buffers concurrently. If incomming information is just written to a buffer with no checks for the buffer size, an
attacker might be able to overwrite data in the memory and change the flow of the program. This is called a buffer
overflow attack and can lead to an attacker being able to control the host running the network application.
\cite{821514}

Another problem with C and C++ is thread safety. Parallelization and preventing race conditions is completly up to the
programmer. When sharing data between multiple threads without proper synchronization, many errors will only occur when
in production with a lot of concurrent access and a higher load on the server.

Rust on the other hand is also a compiled language, but the compiler guarantees for memory- and thread-safety. This
means it profits from the fast speeds compiled languages have and also prevents most of the vulnerabilities mentioned
above from happening, thanks to Rust rejecting to compile code which could introduce such issues. To effeciently check
for any unsafe memory accesses or possible data races, Rust uses the system of ownership, borrowing and lifetimes.

\subsection{Ownership, Borrowing and Lifetimes}
In Rust, a part of the code can own a piece of memory. When a function is called with an owned value, the piece of
memory gets moved into that function and the code calling the it is not allowed to access it after the function call.
Often a function does not need complete access to a value. In the case it can borrow a reference to the value. This
enables the code calling the function to still be able to access the piece of memory afterwards. There are also mutable
references in Rust, but it is only allowed to have a single mutable reference to a variable at once.

This can be really useful when working with network applications as this prevents the occurence of data races if a
thread tries to read or write to a buffer while another thread is already writing to it.

The compiler of Rust does not check for illegal buffer accesses, but other than in C the program exits with an error
code (this is called a panic) if the program tries to access an index which is out of bounds. This does not prevent
buffer overflows to take place in advance, but at least the program stops executing immediately instead of letting it
happen and possibly introducing security issues.

Variables usually have a lifetime determined by the code block it was created. If a variable gets out of scope, the
corresponding piece of memory is freed automatically. If a value gets moved into another function, its lifetime changes
with it. Combined with the system of ownership, this can prevent dangling references, illegal memory accesses and
memory leaks from happening at compile time. \cite{c15safe}

\subsection{TCP communication}
The Transmission Control Protocol (TCP) is used for reliable inter-process communication between to systems connected
through a network. You can use it to send a continuous stream of octets to another host. In order to check whether the
data was received by the other host, it assigns a sequence number to each octet sent and waits for an acknowledgment
(ACK) from the receiving user. If no ACK is received in a certain amount of time, the data is sent again. The receiving
host can also use the sequence number to eliminate duplicates and order the segments the right way. \cite{rfc793}

The module \rust{std::net} of the Rust standard library already implements this protocol, so you can work with those
abstractions independent of what plattform the code is currently running. To demonstrate this in a better way, we are
going to implement a small TCP server which accepts connections and prints incomming messages as well as a TCP client,
which connects to our server and sends messages from the command line to it. The following piece of code demonstrates
how messages sent to a \rust{std::net::TcpStream} can be received and printed for the user to read:

\begin{minted}{Rust}
let mut reader = BufReader::new(&stream);

loop {
    let mut buf = String::new();

    match reader.read_line(&mut buf) {
        Ok(size) => {
            if size == 0 {
                break;
            }

            print!("{}", buf);
        }
        Err(e) => {
            eprintln!("{}", e);
            stream.shutdown(Both)?;
            break;
        }
    }
}
\end{minted}

The variable \rust{stream} has the type \rust{TcpStream} and represents a connection between two hosts. Data is being
transmitted when you write it to the stream and the other host can read the received information by reading from the
stream on their side.

As networking functions can fail due to multiple reasons (by instance network failure, package loss, insufficent
permissions, etc.), those functions usually return an instance of the enum \rust{std::io::Result<T>}. If the call was
successful, the returned value corresponds to the returned data, wrapped by the enum variant \rust{Ok(T)}. If the call
has failed, the returned value corresponds to the error value, wrapped by the enum variant \rust{Err(Error)}.

In \textcolor{orange}{line 1} a reader of the type \rust{std::io::BufReader} is created. It can be inefficient to read
from the stream with small and repeated calls. In this example we want to read whole lines from the stream, so the
reader can maintain the data in its in-memory buffer until a whole line was received.

Now the example continues to loop and wait for a new message until the connection is closed. \rust{buf} is a simple,
mutable \rust{String} new messages get written into. In \textcolor{orange}{line 6} the result of the call
\rust{reader.read_line(&mut buf)} is matched.

In case the call was successful, the received line is written into \rust{buf} and the program enters the first match
arm. The variable \rust{size} equals the length of the received data. If this is equal to zero it means that the
connection was closed and we can break out of the loop. Otherwise the content of the buffer is written to the command
line using the \rust{print!} macro.

In case reading has failed, the error value is returned and the program enters the second match arm. Here the error
message is printed to the error output and the program tries to shutdown the stream using
\rust{stream.shutdown(Both)?}. The method takes an enum of the type \rust{std::net::Shutdown} as an argument which
decides, how the stream should get closed. \rust{Both} means that both the reading and the writing portions of the
stream should be shut down. The \rust{?} operator tries to unwrap the \rust{Result} returned by the function and
returns immediately if the result is equal to an \rust{Err}. If the unwrap was successful, the program ignores the
result and simply breaks out of the loop.

The example above can be used to handle a connection to a single host and print all the received data until the
connection is closed. To actually run the code, we still have to initialize the stream in the first place. To make
everything simpler, let us assume that the example above is wrapped into a method called
\rust{handle_client(stream: std::io::TcpStream)}:

\begin{minted}{Rust}
let listener = TcpListener::bind(ADDRESS)
    .expect("Bind to address");

for stream in listener.incoming() {
    if let Ok(stream) = stream {
        handle_client(stream)
            .expect("Handle client");
    }
}
\end{minted}

First a listener of the type \rust{std::net::TcpListener} has to be created by binding it to \rust{ADDRESS}. The
constant \rust{ADDRESS} has the type \rust{&str} and contains the address and port (e.g. "127.0.0.1:8080") on which the
server should listen for new incomming connections. The method \rust{expect} is another way to handle the return type
\rust{Result}. It tries to unwrap the \rust{Ok} value if there is any and panics with a message including the argument
and the \rust{Err} value if it fails.

A \rust{TcpListener} has an \rust{accept} method, which blocks the calling thread until a new TCP connection is found
and returns the \rust{TcpStream} and the address of the other host if successful. The method \rust{incoming} returns an
iterator over new connections received by the listener. Iterating over it is equivalent to repeatedly calling
\rust{accept} on the same listener.

We can now use a for loop to keep listening for a new TCP connection as soon as the contact to the current host is
lost. The if statement in \textcolor{orange}{line 5} utilizes pattern matching using the keyword \rust{let} to check
if the connection was successful. If the returned value of the \rust{TcpListener} is an \rust{Err} it gets discarded
and the listener tries to find another host.

In case a connection was established successfully, our function \rust{handle_client} is called with \rust{stream} as an
argument. As the handeling of the client can also result in errors, the \rust{expect} method is used once again to
panic if something failed. An alternative approach would be to check the returned value of \rust{handle_client} and
only print the error to the command line. This would result the server to be more stable and not panic completly if an
error occurs in handeling the current connection.

Now the only thing we need to actually use our server is a client to connect to. A simple TCP client is implemented in
this example:

\begin{minted}{Rust}
let mut stream = TcpStream::connect(ADDRESS)?;

loop {
    let mut buf = String::new();

    match stdin().read_line(&mut buf) {
        Ok(_) => {
            if buf.trim() != "exit" {
                stream.shutdown(Both)?;
                break;
            }

            let bytes = buf.as_bytes();

            stream
                .write_all(bytes)
                .expect("Writing");
        }
        Err(e) => {
            eprintln!("{}", e);
            stream.shutdown(Both)?;
            break;
        }
    }
}
\end{minted}

First a connection to the server is established using the function \rust{TcpStream::connect}, which takes
\rust{ADDRESS} as an argument. The constant \rust{ADDRESS} is similar to the constant we have used in the server and
corresponds to the address and the port of the server we want to connect to, represented as the type \rust{&str}. This
time no \rust{TcpListener} is needed, because the other host is already listening for connections and we want to
establish a connection explicitly to this host. The returned result of the function is unwrapped using \rust{?} to
panic if something went wrong.

After that the program enters a loop and keeps iterating until the connection was closed. In \textcolor{orange}{line 4}
a \rust{String} called \rust{buf} is created. This variable is used to save the console input of the user and then send
it to the server.

In \textcolor{orange}{line 6} the method \rust{read_line} of \rust{std::io::Stdin} is used to read the next
line from the command line. It takes a mutable reference to the buffer the input should be read into as an argument and
returns a \rust{Result} corresponding to whether reading was successful.

If it was, the content of \rust{buf} is trimmed to remove leading and trailing whitespaces and checked whether it
matches "exit". If that is the case, the \rust{shutdown} method of the stream is used to close the current connection
and the program breaks out of the loop. Otherwise the input string is converted into a byte slice using
the \rust{String} method \rust{as_bytes}. The method \rust{write_all} of the stream takes this slice as an argument and
sends it directly to the server. As this is another method which can fail due to networking issues, it again returns an
\rust{Result} which is unwrapped through the \rust{expect} method.

If reading from the command line failed, the program handles it exactly the same as the server handles read failure
from the stream: The error gets printed to the error output and the program tries to shut down the current stream. If
that was successful it breaks out of the loop resulting the program to terminate.

When using TCP it can be really difficult to detect whether the connection to the server was lost, as the client is
only sending and not receiving any information. This means if we try to close the connection from the server side, the
client will not terminate immediately but usually only after sending a message and not receiving and ACK from the
server in time. A way to resolve this problem would be to implement some kind of ping between the client and the server
in a certain timeframe to check if the other side is still connected. If the time with no ping received exceeds a
certain timeframe, the connection was probably lost and the stream can be closed.

\subsection{UDP communication}
Text
