% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\section{Networking in Rust}
Rust is an open-source programming language developed by Mozilla introducing memory-safety without a runtime or garbage
collection. Its standard library provides networking primitives for basic TPC/UDP communication, which allows basic
socket communication and error handeling out of the box. \cite{rust-language}

\subsection{Advantages of using Rust for networking}
There are usually different approaches when it comes to picking a language for networking, especially if you want to
implement a new transport protocol on a lower level.

You can use a scripting language like Python or JavaScript. With such languages you are able to easily import libraries
to give you a basic networking API and they offer a simple syntax allowing fast prototyping. As those languages usually
are interpreted, they often perform much slower compared to executing compiled binary files as the instructions first
have to get translated by the interpreter before being executed.

If speed and scalability is an important factor (as it is most of the time), a compiled language can be a good choice.
This is the reason why many networking libraries are writting in C and C++. Those two languages do not guarantee memory
safety. If a programmer makes a mistake, the compiler does not check for undefined behavior and just falls back to some
default action. This can lead to corruption in the memory.

This can particularly be a problem when working with networking applications as you often have to read and write to
buffers concurrently. If incomming information is just written to a buffer with no checks for the buffer size, an
attacker might be able to overwrite data in the memory and change the flow of the program. This is called a Buffer
Overflow attack and can lead to an attacker being able to control the host running the network application.
\cite{821514}

Another problem with C and C++ is thread safety. Parallelization and preventing race conditions is completly up to the
programmer. When sharing data between multiple threads without proper synchronization, many errors will only occur when
in production with a lot of concurrent access and a higher load on the server.

Rust on the other hand is also a compiled language, but the compiler guarantees for memory- and thread-safety. This
means it profits from the fast speeds compiled languages have and also prevents most of the vulnerabilities mentioned
above from happening, because Rust rejects to compile code which could introduce such issues. To effeciently check for
any unsafe memory accesses or possible data races, Rust uses the system of ownership, borrowing and lifetimes.

\subsection{Ownership, Borrowing and Lifetimes}
Text

\subsection{TCP and UDP communication}
Text
