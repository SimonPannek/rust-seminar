% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\section{Networking in Rust}
It was already mentioned before that Rust uses verification at compile time to stop compiling the code if something
unsafe could happen at runtime without it explicitly being marked as unsafe. To effeciently check for any of those
unsafe memory accesses or possible data races, Rust uses the system of ownership, borrowing and lifetimes. It is very
important to be familiar with those concepts before actually starting to implement an own network application, because
otherwise many compiler errors will not seem rational.

\subsection{Ownership, borrowing and lifetimes}
In Rust, a part of the code can own a piece of memory. When a function is called with an owned value, the piece of
memory gets moved into that function and the code calling it is not allowed to access it after the function call.
Sometimes a function does not need complete access to a value. If that is the case it can borrow a reference to the
value. This enables the code calling the function to still be able to access the piece of memory afterwards. There are
also mutable references in Rust, but it is only allowed to have a single mutable reference to a variable at once.

This can be really useful when working with network applications as this prevents the occurence of data races if a
thread tries to read or write to a buffer while another thread is already writing to it.

The compiler of Rust does not check for illegal array accesses, but other than in C the program exits with an error
code (this is called a panic) if the program tries to access an index which is out of bounds. This does not prevent
buffer overflows to take place in advance, but at least the program stops executing immediately instead of letting it
happen and possibly introducing security issues.

Variables usually have a lifetime determined by the code block it was created. If a variable gets out of scope, the
corresponding piece of memory is freed automatically. If a value gets moved into another function, its lifetime changes
with it. Combined with the system of ownership, this can prevent dangling references, illegal memory accesses and
memory leaks from happening at compile time. \cite{c15safe}

\subsection{TCP communication}
The Transmission Control Protocol (TCP) is used for reliable inter-process communication between two systems connected
through a network. You can use it to send a continuous stream of octets to another host. In order to check whether the
data was received by the other host, it assigns a sequence number to each octet sent and waits for an acknowledgment
(ACK) from the receiving user. If no ACK is received in a certain amount of time, the data is sent again. The receiving
host can also use the sequence number to eliminate duplicates and order the segments the right way. \cite{RFC0793}

The module \rust{std::net} of the Rust standard library already implements this protocol, so you can work with those
abstractions independent of what plattform the code is currently running. To demonstrate this in a better way, we are
going to implement a small TCP server which accepts connections and prints incoming messages as well as a TCP client,
which connects to our server and sends messages from the command line to it. Figure 1 demonstrates how messages sent to
a \rust{std::net::TcpStream} can be received and printed for the user to read.

\begin{figure}[ht]
    \begin{minted}{Rust}
let mut reader = BufReader::new(&stream);

loop {
    let mut buf = String::new();

    match reader.read_line(&mut buf) {
        Ok(0) => break,
        Ok(_) => print!("{}", buf),
        Err(e) => {
            eprintln!("{}", e);
            stream.shutdown(Both)?;
            break;
        }
    }
}
    \end{minted}
    \caption{TCP client handeling}
\end{figure}

The variable \rust{stream} has the type \rust{TcpStream} and represents a connection between two hosts. Data is being
transmitted when you write it to the stream and the other host can read the received information by reading from the
stream on their side.

As networking functions can fail due to multiple reasons (by instance network failure, package loss, insufficent
permissions, etc.), those functions usually return an instance of the enum \rust{std::io::Result<T>}. If the call was
successful, the returned value corresponds to the returned data, wrapped by the enum variant \rust{Ok(T)}. If the call
has failed, the returned value corresponds to the error value, wrapped by the enum variant \rust{Err(Error)}.

In \textcolor{orange}{line 1} a reader of the type \rust{std::io::BufReader} is created. It can be inefficient to read
from the stream with small and repeated calls. In this example we want to read whole lines from the stream, so the
reader can maintain the data in its in-memory buffer until a whole line was received.

Now the example continues to loop and wait for a new message until the connection is closed. \rust{buf} is a simple,
mutable \rust{String} new messages get written into. In \textcolor{orange}{line 6} the result of the call
\rust{reader.read_line(&mut buf)} is matched.

In case the call was successful but the amount of read bytes is equal to 0 this means that the connection was closed
and we can break out of the loop. If at least one byte was read, the received line is written into \rust{buf} and the
program enters the second match arm, writing the content of the buffer to the command line using the
\nohighlight{print!} macro.

In case reading has failed, the error value is returned and the program enters the third match arm. Here the error
message is printed to the error output and the program tries to shutdown the stream using
\rust{stream.shutdown(Both)?}. This method takes an enum of the type \rust{std::net::Shutdown} as an argument which
decides, how the stream should get closed. \rust{Both} means that both the reading and the writing portions of the
stream should be shut down. The \rust{?} operator tries to unwrap the \rust{Result} returned by the function and
returns immediately if the result is equal to an \rust{Err}. If the unwrap was successful, the program ignores the
result and simply breaks out of the loop.

The example of figure 1 can be used to handle a connection to a single host and print all the received data until the
connection is closed. To actually run the code, we still have to initialize the stream in the first place. To make
everything simpler, let us assume that the code of figure 1 is now wrapped into a method called
\rust{handle_client}, taking the \rust{TcpStream} it handles as an argument. We are now able to call this function in
the code of figure 2.

\begin{figure}[ht]
    \begin{minted}{Rust}
let listener = TcpListener::bind(ADDRESS)
    .expect("Bind to address");

for stream in listener.incoming() {
    if let Ok(stream) = stream {
        handle_client(stream)
            .expect("Handle client");
    }
}
    \end{minted}
    \caption{TCP listener}
\end{figure}

First a listener of the type \rust{std::net::TcpListener} has to be created by binding it to \rust{ADDRESS}. The
constant \rust{ADDRESS} has the type \rust{&str} and contains the address and port (e.g. "127.0.0.1:8080") on which the
server should listen for new incoming connections. The method \rust{expect} is another way to handle the return type
\rust{Result}. It tries to unwrap the \rust{Ok} value if there is any and panics with a message including the argument
and the \rust{Err} value formatted as a \rust{String} if it fails.

A \rust{TcpListener} has an \rust{accept} method, which blocks the calling thread until a new TCP connection is found
and returns the \rust{TcpStream} and the address of the other host if successful. The method \rust{incoming} returns an
iterator over new connections received by the listener. Iterating over it is equivalent to repeatedly calling
\rust{accept} on the same listener.

We can now use a for loop to keep listening for a new TCP connection as soon as the contact to the current host is
lost. The if statement in \textcolor{orange}{line 5} utilizes pattern matching using the keyword \rust{let} to check
if the connection was successful. If the returned value of the \rust{TcpListener} is an \rust{Err}, it gets discarded
and the listener tries to find another host.

In case a connection was established successfully, our function \rust{handle_client} is called with \rust{stream} as an
argument. As the handeling of the client can also result in errors, the \rust{expect} method is used once again to
panic if something has failed. An alternative approach would be to check the returned value of \rust{handle_client} and
only print the error to the command line. This would result the server to be more stable and not panic completly if an
error occurs in handeling the current connection.

Now the only thing we need to actually use our server is a client to connect to. A simple TCP client is implemented in
figure 3.

\begin{figure}[ht]
    \begin{minted}{Rust}
let mut stream = TcpStream::connect(ADDRESS)?;

loop {
    let mut buf = String::new();

    match stdin().read_line(&mut buf) {
        Ok(_) => {
            if buf.trim() != "exit" {
                stream.shutdown(Both)?;
                break;
            }

            let bytes = buf.as_bytes();

            stream
                .write_all(bytes)
                .expect("Writing");
        }
        Err(e) => {
            eprintln!("{}", e);
            stream.shutdown(Both)?;
            break;
        }
    }
}
    \end{minted}
    \caption{TCP client}
\end{figure}

First a connection to the server is established using the function \rust{TcpStream::connect}, which takes
\rust{ADDRESS} as an argument. The constant \rust{ADDRESS} is similar to the constant we have used in the server and
corresponds to the address and the port of the server we want to connect to, represented as the type \rust{&str}. This
time no \rust{TcpListener} is needed, because the other host is already listening for connections and we want to
establish a connection explicitly to this host. The returned result of the function is unwrapped using \rust{?} to
panic if something went wrong.

After that the program enters a loop and keeps iterating until the connection was closed. In \textcolor{orange}{line 4}
a mutable \rust{String} called \rust{buf} is created. This variable is used to save the console input of the user and
then send it to the server.

In \textcolor{orange}{line 6} the method \rust{read_line} of \rust{std::io::Stdin} is used to read the next
line from the command line. It takes a mutable reference to the buffer the input should be read into as an argument and
returns a \rust{Result} corresponding to whether reading was successful.

If it was, the content of \rust{buf} is trimmed to remove leading and trailing whitespaces and checked whether it
matches "exit". If that is the case, the \rust{shutdown} method of the stream is used to close the current connection
and the program breaks out of the loop. Otherwise the input string is converted into a byte slice using
the \rust{String}-method \rust{as_bytes}. The method \rust{write_all} of the stream takes this slice as an argument and
sends it directly to the server. As this is another method which can fail due to networking issues, it again returns an
\rust{Result} which is unwrapped through the \rust{expect} method.

If reading from the command line has failed, the program handles it exactly the same as the server handles read failure
from the stream: The error gets printed to the error output and the program tries to shut down the current stream. If
that was successful, it breaks out of the loop resulting the program to terminate.

When using TCP it can be really difficult to detect whether the connection to the server was lost, as the client is
only sending and not receiving any information. This means if we try to close the connection from the server side, the
client will not terminate immediately but usually only after sending a message and not receiving an ACK from the server
in time. A way to resolve this problem would be to implement some kind of ping between the client and the server in a
certain timeframe to check if the other side is still connected. If the time with no ping received exceeds this
timeframe, the connection was probably lost and the stream can be closed.

\subsection{UDP communication}
The User Datagram Protocol (UDP) is less reliable than the Transmission Control Protocol. Differently to TCP, UDP tries
to send messages to other programs with a minimal amount of protocol mechanism. This means it offers no protection
against package duplication and does not check whether the sent data arrived and if it did in what order. As a
consequence you do not have to listen for new hosts and actively establish a connection to another host before sending
any data. UDP is commonly used, if you do not need reliable delivery of streams and small amount of package loss does
not matter. A typical example for UDP applications would be media streaming. \cite{RFC0768}

When trying to communicate over UDP in Rust, you can use the struct \rust{std::net::UdpSocket}. It provides methods to
bind to an address, send and receive data. As we do not need a server to listen for new connections, the following
example will be split into a sender who sends data and into a receiver who receives those messages. In figure 4 there
is an example, how the code on the receiving end could look like.

\begin{figure}[ht]
    \begin{minted}{Rust}
let socket = UdpSocket::bind(ADDRESS)?;

loop {
    let mut buf = [0u8; 1500];

    match socket.recv_from(&mut buf) {
        Ok(_) => {
            let msg = from_utf8(&buf)
                .expect("Convert data");

            print!("{}", msg);
        }
        Err(e) => {
            eprintln!("{}", e);
            break;
        }
    }
}
    \end{minted}
    \caption{UDP receiver}
\end{figure}

In the beginning a socket is created by calling the \rust{bind} method and giving the address the socket should listen
to as an argument. The result is unwrapped using \rust{?} and then moved into a variable. After that the program keeps
looping until an error occured or it is closed explicitly. As there are not connections between two hosts, the socket
cannot close when a connection is lost. Another difference to using TCP is that the socket is able to listen to
incoming messages of multiple hosts.

When trying to receive an incoming message, we first have to initialize a buffer to save the data of the other host.
A \rust{UdpSocket} does not implement the trait \rust{std::io::Read}. This means you cannot create a \rust{BufReader}
instance in order to read the data from the socket. Alternatively we have to read the messages as bytes and then parse
them into a \rust{String} later. The variable \rust{buf} in this case is a byte slice of the length \rust{1500}. If you
know the size of the data beforehand, you can adjust the buffer length according to this, but as we do not know
anything about the data we are going to receive, this example uses the size of a typical UDP MTU (Maximum Transmission
Unit). If a message is larger than the buffer, it is going to get cut off.

In \textcolor{orange}{line 6} the method \rust{recv_from} is used to read the next arriving package into \rust{buf}. If
the call was successful, the program enters the first match arm, tries to convert the byte slice into a \rust{&str} and
panics in case of a failure using the \rust{expect} method. After that the message gets printed to the command line. If
the call has failed, the program prints the error and breaks out of the loop.

To send data to this receiver, you cannot just use the TCP client implemented before as it uses a different protocol. In
figure 5 you can see a small implementation of an UDP sender.

\begin{figure}[ht]
    \begin{minted}{Rust}
let socket = UdpSocket::bind("0.0.0.0:0")?;

loop {
    let mut buf = String::new();

    match stdin().read_line(&mut buf) {
        Ok(_) => {
            if buf.trim() == "exit" {
                break;
            }

            let bytes = buf.as_bytes();

            socket
                .send_to(bytes, ADDRESS)
                .expect("Sending");
        }
        Err(e) => {
            eprintln!("{}", e);
            break;
        }
    }
}
    \end{minted}
    \caption{UDP sender}
\end{figure}

Here the socket is not bound to the address of the host we want to send messages to. Rather the \rust{bind} method is
given the static address "0.0.0.0:0". This is because of the UDP protocol. As there is no set connection between two
hosts, our sender needs an own address and port in order to receive answers from the other host. By giving the
\rust{bind} method the static address of "0.0.0.0:0" as an argument, we implicitly state that the host should use its
own ip address and choose any free, available port it is allowed to use. It would also work to set the port explicitly,
but this risks choosing a port which is already used by another program.

From this point on the sender is really similar to the TCP client: In a continous loop the user input from the command
line is written into \rust{buf}.

If the reading was successful, the input is first trimmed and then checked whether it
matches "exit". If that is the case, the program simply breaks out of the loop. We do not have to shutdown any stream
here, as there is no connection in the first place. Otherwise the input is converted into bytes using the method
\rust{as_bytes} and then sent to the other host by calling \rust{send_to} on the socket, giving it the byte slice and
the address of the other host as arguments. The result of this method call is again unwrapped using \rust{expect} to
panic in case of an error.
